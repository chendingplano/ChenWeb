package appdatastores

import (
	"database/sql"
	"fmt"
	"log"
	"time"

	"github.com/chendingplano/shared/go/api/ApiTypes"
	"github.com/chendingplano/shared/go/api/databaseutil"
	_ "github.com/lib/pq"
)

type TableDocumentsDef struct {
	DocID 			string `json:"doc_id"`
	UserID 		   *string `json:"user_id"`
	DocName 	   *string `json:"doc_name"`
	DocNo 		   *string `json:"doc_no"`
	DocDesc 	   *string `json:"doc_desc"`
	DocSummary 	   *string `json:"doc_summary"`
	DocKeywords    *string `json:"doc_keywords"`
	DocTags 	   *string `json:"doc_tags"`
	FileURL 		string `json:"file_url"`
	ImageURL	   *string `json:"image_url"`
	DocType 		string `json:"doc_type"`
	DocSource 	   *string `json:"doc_source"`
	DocScope 		string `json:"doc_scope"`
	DocStatus 		string `json:"doc_status"`
	ProcessStatus 	string `json:"process_status"`
	CreatedAt 	   *string `json:"created_at"`
	UpdatedAt 	   *string `json:"updated_at"`
}

const (
	DocumentsTableDesc = `
		Table Documents stores documents. Whenever a document is uploaded,
		a record in this table is created for it.
		The table offers insert, update and query operations, but not
		delete. Deleting a doc is to make its 'status' field to 'deleted'.
	`
	DocumentsField_DocID = `
		Field 'doc_id', mandatory, a positive non-zero integer serving as the primary 
		key, assigned by caller
	`

	DocumentsField_UserID = `
		Field 'user_id': optional, identifies the user who owns the document.
		If it is null or empty, the document is not owned by any user.
		Otherwise (not empty), it MUST identified a valid user.
	`

	DocumentsField_DocName = `
		Field 'doc_name': optional, the document name.
	`

	DocumentsField_DocNo = `
		Field 'doc_no': optional, the document number. Some documents may be
		assigned document numbers for easy identificiation and reference.
		Note that document numbers may not be unique, though they normally
		are unique.
	`

	DocumentsField_DocDesc = `
		Field 'doc_desc': optional, the description about a document.
	`

	DocumentsField_DocSummary = `
		Field 'doc_summary': optional, the summary about a document. Document
		summaries can be extracted from the document or generated by LLMs.
	`

	DocumentsField_DocKeywords = `
		Field 'doc_keywords': optional, the keywords of the document.
		Keywords may be extracted from the document or generated by LLMs.
	`

	DocumentsField_DocTags = `
		Field 'doc_tags': optional, the tags of the document.
		Tags are normally assigned by users, but occasionally generated by LLMs.
	`

	DocumentsField_FileURL = `
		Field 'file_url': mandatory, the URL to retrieve the document.
	`

	DocumentsField_ImageURL = `
		Field 'image_url': optional, the URL for the document cover page.
	`

	DocumentsField_DocType = `
		Field 'doc_type': mandatory, identifies document type, supported types include:
		"PDF", "DOC", "DOCX", "PPT", "PPTX", "CSV", "JSON", "PNG", etc.
	`

	DocumentsField_DocSource = `
		Field 'doc_source': optional, identifies document source, allowed values:
		"uploaded by user",
		"crawled from <url>",
		"from app <app_name>",
	`

	DocumentsField_DocScope = `
		Field 'doc_scope': mandatory, the document scope, allowed values:
		"public", "private", "group-shared", "accessed-by-token".
	`

	DocumentsField_DocStatus = `
		Field 'doc_scope': mandatory, identify the document status. Allowed values:
		'active', 'deleted', 'suspended'.
	`

	DocumentsField_ProcessStatus = `
		Field 'process_status': mandatory, identify the document process status. Allowed values:
		'uploaded': file being uploaded but not processed yet, 
		'acked': the receival of the document has been acknowledged,
		'parsed': the document has been parsed,
		'processed': the document has been processed, such as being chunked, embedded, etc.
		`

	DocumentsField_CreatedAt = `
		Field 'created_at': mandatory, the creation time, defaulted to the system current time.
	`

	DocumentsField_UpdatedAt = `
		Field 'updated_at': mandatory, the last updated time.
	`
)	
	
func CreateDocumentsTable(
            db *sql.DB, 
            db_type string,
            table_name string) error {
    var stmt string
	const common_fields = 
            "doc_id 		BIGINT 			NOT NULL PRIMARY KEY COMMENT '" + DocumentsField_DocID + "', " +
            "user_id 		VARCHAR(128) 	DEFAULT NULL COMMENT '" + DocumentsField_UserID + "', " +
            "doc_name		VARCHAR(256) 	DEFAULT NULL COMMENT '" + DocumentsField_DocName + "', " +
            "doc_no 		VARCHAR(256) 	DEFAULT NULL COMMENT '" + DocumentsField_DocNo + "', " +
            "doc_desc 		TEXT 			DEFAULT NULL COMMENT '" + DocumentsField_DocDesc+ "', " +
            "doc_summary 	TEXT 			DEFAULT NULL COMMENT '" + DocumentsField_DocSummary+ "', " +
            "doc_keywords	TEXT 			DEFAULT NULL COMMENT '" + DocumentsField_DocKeywords+ "', " +
            "doc_tags 		TEXT 			DEFAULT NULL COMMENT '" + DocumentsField_DocTags+ "', " +
            "file_url 		TEXT		 	NOT NULL COMMENT '" + DocumentsField_FileURL+ "', " +
            "image_url 		TEXT			DEFAULT NULL COMMENT '" + DocumentsField_ImageURL + "', " +
            "Doc_type		VARCHAR(32) 	NOT NULL COMMENT '" + DocumentsField_DocType + "', " +
            "doc_source		VARCHAR(128) 	DEFAULT NULL COMMENT '" + DocumentsField_DocSource+ "', " +
            "doc_scope		VARCHAR(32) 	NOT NULL COMMENT '" + DocumentsField_DocScope + "', " +
            "doc_status		VARCHAR(32) 	NOT NULL COMMENT '" + DocumentsField_DocStatus+ "', " +
            "process_status	VARCHAR(32) 	NOT NULL COMMENT '" + DocumentsField_ProcessStatus+ "', " +
            "created_at 	TIMESTAMP 		DEFAULT CURRENT_TIMESTAMP COMMENT '" + DocumentsField_CreatedAt+ "', " +
            "updated_at 	TIMESTAMP 		DEFAULT CURRENT_TIMESTAMP COMMENT '" + DocumentsField_UpdatedAt+ "'"

    switch db_type {
    case ApiTypes.MysqlName:
         stmt = "CREATE TABLE IF NOT EXISTS " + table_name + "(" + common_fields +
            ") ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;"

    case ApiTypes.PgName:
         stmt = "CREATE TABLE IF NOT EXISTS " + table_name + "(" + common_fields + ")"

    default:
        err := fmt.Errorf("database type not supported:%s (CWB_DOC_044)", db_type)
        log.Printf("***** Alarm:%s", err.Error())
        return err
    }

    err := databaseutil.ExecuteStatement(db, stmt)
    if err != nil {
        error_msg := fmt.Errorf("failed creating table (CWB_DOC_051), err: %w, stmt:%s", err, stmt)
        log.Printf("***** Alarm: %s", error_msg.Error())
        return error_msg
    }

    log.Printf("Creating table '%s' success (CWB_DOC_056)", table_name)

    return nil
}

// AddDocumentsRecord inserts a new document record into the documents table
func AddDocumentsRecord(db *sql.DB, tableName string, record TableDocumentsDef) error {
	stmt := fmt.Sprintf(`
		INSERT INTO %s (
			doc_id, user_id, doc_name, doc_no, doc_desc, doc_summary, 
			doc_keywords, doc_tags, file_url, image_url, doc_type, 
			doc_source, doc_scope, doc_status, process_status
		) VALUES (
			$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15
		)`, tableName)

	_, err := db.Exec(stmt,
		record.DocID,
		record.UserID,
		record.DocName,
		record.DocNo,
		record.DocDesc,
		record.DocSummary,
		record.DocKeywords,
		record.DocTags,
		record.FileURL,
		record.ImageURL,
		record.DocType,
		record.DocSource,
		record.DocScope,
		record.DocStatus,
		record.ProcessStatus,
	)

	if err != nil {
		errorMsg := fmt.Errorf("failed to insert document record (CWB_DOC_061), err: %w", err)
		log.Printf("***** Alarm: %s", errorMsg.Error())
		return errorMsg
	}

	log.Printf("Successfully inserted document record with doc_id: %s (CWB_DOC_066)", record.DocID)
	return nil
}

// MarkDocumentAsDeleted marks a document as deleted by updating its doc_status to 'deleted'
func MarkDocumentAsDeleted(db *sql.DB, tableName string, docID int64) error {
	stmt := fmt.Sprintf(`
		UPDATE %s 
		SET doc_status = 'deleted', updated_at = CURRENT_TIMESTAMP 
		WHERE doc_id = $1`, tableName)

	result, err := db.Exec(stmt, docID)
	if err != nil {
		errorMsg := fmt.Errorf("failed to mark document as deleted (CWB_DOC_071), err: %w", err)
		log.Printf("***** Alarm: %s", errorMsg.Error())
		return errorMsg
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		errorMsg := fmt.Errorf("failed to get rows affected (CWB_DOC_076), err: %w", err)
		log.Printf("***** Alarm: %s", errorMsg.Error())
		return errorMsg
	}

	if rowsAffected == 0 {
		errorMsg := fmt.Errorf("no document found with doc_id: %d (CWB_DOC_081)", docID)
		log.Printf("***** Warning: %s", errorMsg.Error())
		return errorMsg
	}

	log.Printf("Successfully marked document as deleted, doc_id: %d (CWB_DOC_086)", docID)
	return nil
}

// QueryCondition represents a query condition with field name, operator, and value
type QueryCondition struct {
	FieldName string
	Operator  string // =, !=, >, <, >=, <=, LIKE, IN
	Value     interface{}
}

// QueryDocuments queries documents based on multiple conditions with a limit
func QueryDocuments(db *sql.DB, tableName string, conditions []QueryCondition, limit int) ([]TableDocumentsDef, error) {
	query := fmt.Sprintf("SELECT doc_id, user_id, doc_name, doc_no, doc_desc, doc_summary, "+
		"doc_keywords, doc_tags, file_url, image_url, doc_type, doc_source, doc_scope, "+
		"doc_status, process_status, created_at, updated_at FROM %s", tableName)

	var args []interface{}
	argIndex := 1

	if len(conditions) > 0 {
		query += " WHERE "
		for i, cond := range conditions {
			if i > 0 {
				query += " AND "
			}
			query += fmt.Sprintf("%s %s $%d", cond.FieldName, cond.Operator, argIndex)
			args = append(args, cond.Value)
			argIndex++
		}
	}

	if limit > 0 {
		query += fmt.Sprintf(" LIMIT %d", limit)
	}

	rows, err := db.Query(query, args...)
	if err != nil {
		errorMsg := fmt.Errorf("failed to query documents (CWB_DOC_091), err: %w, query: %s", err, query)
		log.Printf("***** Alarm: %s", errorMsg.Error())
		return nil, errorMsg
	}
	defer rows.Close()

	var documents []TableDocumentsDef
	for rows.Next() {
		var doc TableDocumentsDef
		err := rows.Scan(
			&doc.DocID,
			&doc.UserID,
			&doc.DocName,
			&doc.DocNo,
			&doc.DocDesc,
			&doc.DocSummary,
			&doc.DocKeywords,
			&doc.DocTags,
			&doc.FileURL,
			&doc.ImageURL,
			&doc.DocType,
			&doc.DocSource,
			&doc.DocScope,
			&doc.DocStatus,
			&doc.ProcessStatus,
			&doc.CreatedAt,
			&doc.UpdatedAt,
		)
		if err != nil {
			errorMsg := fmt.Errorf("failed to scan document row (CWB_DOC_096), err: %w", err)
			log.Printf("***** Alarm: %s", errorMsg.Error())
			return nil, errorMsg
		}
		documents = append(documents, doc)
	}

	if err = rows.Err(); err != nil {
		errorMsg := fmt.Errorf("error iterating document rows (CWB_DOC_101), err: %w", err)
		log.Printf("***** Alarm: %s", errorMsg.Error())
		return nil, errorMsg
	}

	log.Printf("Successfully queried %d documents (CWB_DOC_106)", len(documents))
	return documents, nil
}

// GenerateRandomRecords generates N random document records for testing purposes
func GenerateRandomRecords(numRecords int) []TableDocumentsDef {
	documentNames := []string{
		"Product Requirements Document", 
		"Technical Specification", 
		"User Manual",
		"API Documentation", 
		"System Architecture Design", 
		"Test Plan",
		"Project Proposal", 
		"Budget Report", 
		"Marketing Strategy",
		"Research Paper", 
		"Compliance Guidelines", 
		"Security Policy",
		"Employee Handbook", 
		"Training Materials", 
		"Release Notes",
		"Business Plan", 
		"Financial Statement", 
		"Quality Assurance Report",
		"Installation Guide", 
		"Configuration Manual", 
		"Troubleshooting Guide",
		"Meeting Minutes", 
		"Contract Agreement", 
		"Service Level Agreement",
	}

	descriptions := []string{
		"Comprehensive documentation outlining key features and requirements",
		"Detailed technical specifications for system implementation",
		"Step-by-step guide for end users and administrators",
		"Complete API reference with examples and best practices",
		"High-level architecture and design patterns documentation",
		"Testing procedures and validation criteria",
		"Strategic planning document for project execution",
		"Financial analysis and budget allocation details",
		"Marketing initiatives and target audience strategies",
		"In-depth research findings and recommendations",
		"Regulatory compliance and industry standards guide",
		"Information security protocols and procedures",
		"Company policies and employee guidelines",
		"Educational materials for staff development",
		"Software release information and change log",
		"Business objectives and operational strategies",
		"Financial performance and accounting records",
		"Quality metrics and improvement processes",
		"Setup instructions and deployment guidelines",
		"System configuration and customization options",
		"Common issues and resolution procedures",
		"Official record of discussions and decisions",
		"Legal agreement terms and conditions",
		"Service expectations and performance metrics",
	}

	keywords := [][]string{
		{"documentation", "requirements", "specifications"},
		{"technical", "architecture", "design"},
		{"user guide", "manual", "instructions"},
		{"API", "integration", "endpoints"},
		{"security", "compliance", "policy"},
		{"testing", "quality", "validation"},
		{"business", "strategy", "planning"},
		{"financial", "budget", "reporting"},
		{"training", "education", "learning"},
		{"research", "analysis", "findings"},
	}

	tags := [][]string{
		{"important", "reviewed", "approved"},
		{"draft", "in-progress", "pending"},
		{"archived", "reference", "legacy"},
		{"confidential", "internal", "restricted"},
		{"public", "external", "published"},
	}

	docTypes := []string{"PDF", "DOC", "DOCX", "PPT", "PPTX", "CSV", "JSON", "PNG"}
	docSources := []string{"uploaded by user", "crawled from https://example.com", "from app DocumentManager"}
	docScopes := []string{"public", "private", "group-shared", "accessed-by-token"}
	docStatuses := []string{"active", "active", "active", "deleted", "suspended"} // weighted toward active
	processStatuses := []string{"uploaded", "acked", "parsed", "processed"}

	records := make([]TableDocumentsDef, numRecords)

	for i := 0; i < numRecords; i++ {
		docID := fmt.Sprintf("%d", i+1)
		userID := generateUUID()
		
		// Generate random document name
		docName := documentNames[i%len(documentNames)]
		if i >= len(documentNames) {
			docName = fmt.Sprintf("%s v%d", documentNames[i%len(documentNames)], (i/len(documentNames))+1)
		}
		
		// Generate doc_no in format: <random-number>_<year>:<revision>
		randomNum := 10000 + (i * 137) % 90000 // deterministic pseudo-random
		year := 2020 + (i % 5)
		revision := 1 + (i % 5)
		docNo := fmt.Sprintf("%d_%d:%d", randomNum, year, revision)
		
		// Generate description
		docDesc := descriptions[i%len(descriptions)]
		
		// Generate summary
		docSummary := fmt.Sprintf("This document contains %s with detailed information and guidelines.", 
			documentNames[i%len(documentNames)])
		
		// Generate keywords
		keywordSet := keywords[i%len(keywords)]
		docKeywords := ""
		for j, kw := range keywordSet {
			if j > 0 {
				docKeywords += ", "
			}
			docKeywords += kw
		}
		
		// Generate tags
		tagSet := tags[i%len(tags)]
		docTags := ""
		for j, tag := range tagSet {
			if j > 0 {
				docTags += ", "
			}
			docTags += tag
		}
		
		// Generate URLs
		fileURL := fmt.Sprintf("https://storage.example.com/documents/%s.pdf", docID)
		imageURL := fmt.Sprintf("https://storage.example.com/thumbnails/%s.png", docID)
		
		docType := docTypes[i%len(docTypes)]
		docSource := docSources[i%len(docSources)]
		docScope := docScopes[i%len(docScopes)]
		docStatus := docStatuses[i%len(docStatuses)]
		processStatus := processStatuses[i%len(processStatuses)]
		
		records[i] = TableDocumentsDef{
			DocID:         docID,
			UserID:        &userID,
			DocName:       &docName,
			DocNo:         &docNo,
			DocDesc:       &docDesc,
			DocSummary:    &docSummary,
			DocKeywords:   &docKeywords,
			DocTags:       &docTags,
			FileURL:       fileURL,
			ImageURL:      &imageURL,
			DocType:       docType,
			DocSource:     &docSource,
			DocScope:      docScope,
			DocStatus:     docStatus,
			ProcessStatus: processStatus,
			CreatedAt:     nil, // Will be set by database
			UpdatedAt:     nil, // Will be set by database
		}
	}
	
	log.Printf("Generated %d random document records (CWB_DOC_111)", numRecords)
	return records
}

// generateUUID creates a simple UUID-like string
func generateUUID() string {
	// Simple UUID generation for testing purposes
	// In production, use github.com/google/uuid or similar
	return fmt.Sprintf("%08x-%04x-%04x-%04x-%012x",
		randomInt(0, 0xFFFFFFFF),
		randomInt(0, 0xFFFF),
		randomInt(0, 0xFFFF),
		randomInt(0, 0xFFFF),
		randomInt(0, 0xFFFFFFFFFFFF),
	)
}

// randomInt generates a pseudo-random integer between min and max
func randomInt(min, max int) int {
	// Simple pseudo-random for deterministic testing
	// In production, use crypto/rand or math/rand with proper seeding
	seed := int(time.Now().UnixNano())
	return min + (seed % (max - min + 1))
}